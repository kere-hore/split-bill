generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                  String             @id @default(cuid())
  clerkId             String             @unique
  username            String             @unique
  name                String
  email               String             @unique
  phone               String?
  image               String?
  provider            String?
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  bills               Bill[]
  expenses            Expense[]
  createdGroups       Group[]            @relation("CreatedByUser")
  groups              GroupMember[]
  settlements         Settlement[]       @relation("SettlementPayer")
  receivedSettlements Settlement[]       @relation("SettlementReceiver")
  SlackUserMapping    SlackUserMapping[]
  SlackConfigs        SlackConfig[]

  @@index([clerkId])
  @@index([email])
  @@index([createdAt])
}

model Group {
  id                String             @id @default(cuid())
  name              String
  description       String?
  billId            String?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  createdBy         String
  allocationData    String?
  status            String             @default("outstanding")
  paymentReceiverId String?
  expenses          Expense[]
  bill              Bill?              @relation(fields: [billId], references: [id])
  creator           User               @relation("CreatedByUser", fields: [createdBy], references: [id], onDelete: Cascade)
  members           GroupMember[]

  @@index([createdBy])
  @@index([status])
  @@index([createdAt])
  @@index([createdBy, status])
  @@index([billId])
}

model GroupMember {
  id      String @id @default(cuid())
  groupId String
  userId  String
  name    String
  role    String @default("member")
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([groupId])
  @@index([userId])
  @@index([groupId, role])
}

model Expense {
  id          String         @id @default(cuid())
  title       String
  description String?
  amount      Decimal        @db.Decimal(10, 2)
  currency    String         @default("IDR")
  groupId     String
  paidBy      String
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  group       Group          @relation(fields: [groupId], references: [id], onDelete: Cascade)
  payer       User           @relation(fields: [paidBy], references: [id])
  splits      ExpenseSplit[]
}

model ExpenseSplit {
  id        String  @id @default(cuid())
  expenseId String
  userId    String
  amount    Decimal @db.Decimal(10, 2)
  expense   Expense @relation(fields: [expenseId], references: [id], onDelete: Cascade)

  @@unique([expenseId, userId])
}

model Settlement {
  id         String   @id @default(cuid())
  groupId    String
  payerId    String
  receiverId String
  amount     Decimal  @db.Decimal(10, 2)
  currency   String   @default("IDR")
  createdAt  DateTime @default(now())
  status     String   @default("pending")
  updatedAt  DateTime @default(now()) @updatedAt
  payer      User     @relation("SettlementPayer", fields: [payerId], references: [id])
  receiver   User     @relation("SettlementReceiver", fields: [receiverId], references: [id])

  @@index([groupId])
  @@index([payerId])
  @@index([receiverId])
  @@index([status])
  @@index([groupId, status])
  @@index([payerId, status])
}

model Bill {
  id             String         @id @default(cuid())
  merchantName   String
  receiptNumber  String?
  date           DateTime
  time           String?
  subtotal       Decimal        @db.Decimal(10, 2)
  serviceCharge  Decimal        @default(0) @db.Decimal(10, 2)
  tax            Decimal        @default(0) @db.Decimal(10, 2)
  totalAmount    Decimal        @db.Decimal(10, 2)
  paymentMethod  String?
  currency       String         @default("IDR")
  createdBy      String
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  creator        User           @relation(fields: [createdBy], references: [clerkId])
  discounts      BillDiscount[]
  additionalFees BillFee[]
  items          BillItem[]
  groups         Group[]

  @@index([createdBy])
  @@index([date])
  @@index([createdAt])
  @@index([merchantName])
}

model BillItem {
  id          String               @id @default(cuid())
  billId      String
  name        String
  quantity    Int
  unitPrice   Decimal              @db.Decimal(10, 2)
  totalPrice  Decimal              @db.Decimal(10, 2)
  category    String?
  bill        Bill                 @relation(fields: [billId], references: [id], onDelete: Cascade)
  allocations BillItemAllocation[]

  @@index([billId])
  @@index([category])
}

model BillItemAllocation {
  id         String   @id @default(cuid())
  billItemId String
  memberId   String
  quantity   Int
  amount     Decimal  @db.Decimal(10, 2)
  billItem   BillItem @relation(fields: [billItemId], references: [id], onDelete: Cascade)

  @@unique([billItemId, memberId])
}

model BillDiscount {
  id     String  @id @default(cuid())
  billId String
  name   String
  amount Decimal @db.Decimal(10, 2)
  type   String
  bill   Bill    @relation(fields: [billId], references: [id], onDelete: Cascade)
}

model BillFee {
  id     String  @id @default(cuid())
  billId String
  name   String
  amount Decimal @db.Decimal(10, 2)
  bill   Bill    @relation(fields: [billId], references: [id], onDelete: Cascade)
}

model SlackConfig {
  id                 String             @id @default(cuid())
  userId             String             // Owner of the config
  name               String             // Channel/webhook name for selection
  webhookUrl         String
  channelName        String             // #general, #food-orders, etc
  enabledEvents      String[]
  messageFormat      String             @default("rich")
  rateLimitPerMinute Int                @default(10)
  isActive           Boolean            @default(true)
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  User               User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  UserMappings       SlackUserMapping[]

  @@index([userId])
  @@index([isActive])
  @@index([userId, isActive])
}

model SlackUserMapping {
  id            String      @id @default(cuid())
  slackConfigId String      // Tied to specific Slack config
  userId        String?     // Nullable for custom members
  memberName    String      // Display name for all members
  memberEmail   String?     // Email for auto-matching
  slackUsername String?     // @username for mention
  mappingStatus String      @default("pending") // pending, active, skipped
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  SlackConfig   SlackConfig @relation(fields: [slackConfigId], references: [id], onDelete: Cascade)
  User          User?       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([slackConfigId, userId])
  @@unique([slackConfigId, memberName])
  @@index([slackConfigId])
  @@index([slackConfigId, mappingStatus])
  @@index([mappingStatus])
  @@index([memberEmail])
}
